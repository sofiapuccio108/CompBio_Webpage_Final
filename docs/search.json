[
  {
    "objectID": "Homework 4.html",
    "href": "Homework 4.html",
    "title": "Homework 4.QMD",
    "section": "",
    "text": "Question 1\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\n\nn_dims &lt;- sample(3:10, 1)\nprint(n_dims)\n\n[1] 10\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nvals &lt;- 1:(n_dims^2)\nprint(vals)\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n\n# Randomly reshuffle the values\nvals &lt;- sample(vals)\n\n\n# Create a square matrix\nmy_matrix &lt;- matrix(vals, nrow = n_dims, ncol = n_dims)\nmy_matrix #print \n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]   27    7   48    8   40   31   94   60   11    52\n [2,]   73   32   45   46    9   84   37   12   30    82\n [3,]   42   99   14   19   65   10   87   91   25    28\n [4,]   89   34   97   33    4   62   44   93   58    13\n [5,]   29   47   18   90   86   35   56   50   69    75\n [6,]   70   26   53   24   98   74   78   43   77    16\n [7,]   88   80   38   55   64   85   61   57   21    95\n [8,]   81   66   36   51   15   59   41    6   68    54\n [9,]    3   76    5    2   83    1  100   23   49    96\n[10,]   67   17   20   79   22   39   71   63   72    92\n\n#Question 2 \n\n# Transposing the matrix, this flips the matrix over its major diagonal which swaps the rows and columns \nt_matrix &lt;- t(my_matrix) \nt_matrix\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]   27   73   42   89   29   70   88   81    3    67\n [2,]    7   32   99   34   47   26   80   66   76    17\n [3,]   48   45   14   97   18   53   38   36    5    20\n [4,]    8   46   19   33   90   24   55   51    2    79\n [5,]   40    9   65    4   86   98   64   15   83    22\n [6,]   31   84   10   62   35   74   85   59    1    39\n [7,]   94   37   87   44   56   78   61   41  100    71\n [8,]   60   12   91   93   50   43   57    6   23    63\n [9,]   11   30   25   58   69   77   21   68   49    72\n[10,]   52   82   28   13   75   16   95   54   96    92\n\n# Calculating the sum and mean of the first row\nsum(my_matrix[1, ])\n\n[1] 378\n\nmean(my_matrix[1, ])\n\n[1] 37.8\n\n# Sum and mean of the last row\nsum(my_matrix[n_dims, ])\n\n[1] 542\n\nmean(my_matrix[n_dims, ])\n\n[1] 54.2\n\n#note: eig$values are (usually) real or complex numbers, whereas eig$vectors are numeric vectors, often containing decimals (and possibly complex values)\neig &lt;- eigen(my_matrix)\ntypeof(eig$values)\n\n[1] \"complex\"\n\ntypeof(eig$vectors)\n\n[1] \"complex\"\n\n# the output for this code was \"complex\" which means we got complex eigenvalues for this matrix \n\n######Creating a list \n# Create list components\nmy_matrix &lt;- matrix(runif(16), nrow = 4)\nmy_logical &lt;- runif(100) &gt; 0.5\nmy_letters &lt;- sample(letters)\n\n# Combine all of the components into a list\nmy_list &lt;- list(my_matrix = my_matrix, my_logical = my_logical, my_letters = my_letters)\nmy_list\n\n$my_matrix\n          [,1]      [,2]       [,3]      [,4]\n[1,] 0.7146603 0.5387166 0.09225939 0.7775309\n[2,] 0.8716054 0.2518118 0.40613767 0.2503781\n[3,] 0.1460796 0.5118413 0.64357791 0.3220451\n[4,] 0.7634235 0.2683061 0.14047892 0.8668767\n\n$my_logical\n  [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n [13] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n [37]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n [49]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61]  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [73] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n [85]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n [97] FALSE FALSE FALSE FALSE\n\n$my_letters\n [1] \"i\" \"c\" \"n\" \"q\" \"y\" \"g\" \"k\" \"h\" \"z\" \"o\" \"e\" \"d\" \"b\" \"a\" \"f\" \"m\" \"s\" \"x\" \"u\"\n[20] \"w\" \"l\" \"r\" \"v\" \"j\" \"p\" \"t\"\n\n\nQuestion 3\n\n# Checking data types of new list \nnew_list &lt;- list(my_list$my_matrix[2, 2], my_list$my_logical[2], my_list$my_letters[2])\nnew_list\n\n[[1]]\n[1] 0.2518118\n\n[[2]]\n[1] FALSE\n\n[[3]]\n[1] \"c\"\n\ntypeof(new_list[[1]])\n\n[1] \"double\"\n\ntypeof(new_list[[2]])\n\n[1] \"logical\"\n\ntypeof(new_list[[3]])\n\n[1] \"character\"\n\n# The results from this were \"double\", \"logical\", and \"character\" indicating that one list has numbers with decimals, one stores TRUE or FALSE values, and one contains charaters \n\n# Combine them into a single atomic vector \ncombined_vec &lt;- c(new_list[[1]], new_list[[2]], new_list[[3]])\ncombined_vec\n\n[1] \"0.25181183568202\" \"FALSE\"            \"c\"               \n\ntypeof(combined_vec)\n\n[1] \"character\"\n\n# This shows up as \"character\" because there are chracters involved \n\nQuestion 4\n\n# Creating a data frame \nmy_df &lt;- data.frame(my_unis = runif(26, 0, 10), my_letters = sample(LETTERS))\nmy_df\n\n      my_unis my_letters\n1  9.58668228          V\n2  8.27622121          S\n3  8.31507171          A\n4  1.80644660          K\n5  1.15412018          L\n6  6.05434071          Z\n7  2.47323978          F\n8  1.69298360          N\n9  4.71127857          Q\n10 0.09946891          J\n11 2.39590771          R\n12 6.86353714          Y\n13 6.00385505          T\n14 1.59766320          O\n15 6.06006756          M\n16 8.83216710          G\n17 1.48022301          X\n18 0.18547524          U\n19 4.58969951          W\n20 1.56762738          B\n21 7.08327293          P\n22 5.68504352          H\n23 9.94364149          E\n24 0.27310971          I\n25 5.21966374          D\n26 8.99060610          C\n\n# Replace 4 random rows in my_units with NA \nmy_df$my_unis[sample(1:26, 4)] &lt;- NA\nmy_df # In this case, M, O, C, and T were the four random letters being listed as NA \n\n      my_unis my_letters\n1  9.58668228          V\n2  8.27622121          S\n3          NA          A\n4          NA          K\n5  1.15412018          L\n6  6.05434071          Z\n7          NA          F\n8  1.69298360          N\n9  4.71127857          Q\n10 0.09946891          J\n11 2.39590771          R\n12 6.86353714          Y\n13 6.00385505          T\n14 1.59766320          O\n15 6.06006756          M\n16 8.83216710          G\n17 1.48022301          X\n18 0.18547524          U\n19 4.58969951          W\n20 1.56762738          B\n21 7.08327293          P\n22 5.68504352          H\n23 9.94364149          E\n24         NA          I\n25 5.21966374          D\n26 8.99060610          C\n\n# Line of code to identify which rows have the missing values \n# Identify which rows have missing values in my_unis (single line) \n# df was already used , so I needed to rename my dataframe and rewrite the list \nmy_df &lt;- data.frame(my_unis = runif(26, 0, 10), my_letters = sample(LETTERS, 26)) # taking df and making it \"my_df\"\nmy_df$my_unis[sample(1:26, 4)] &lt;- NA # extracts \"my_units\" from the sample \nwhich(is.na(my_df$my_unis))\n\n[1]  2 22 23 26\n\nmy_df &lt;- my_df[order(my_df$my_letters), ]\nmean(my_df$my_unis, na.rm = TRUE)\n\n[1] 4.290715\n\n# (running again) Replace 4 random rows in my_unis with NA (single line)\nmy_df$my_unis[sample(1:26, 4)] &lt;- NA\nmy_df\n\n      my_unis my_letters\n2          NA          A\n9  1.13757144          B\n21 7.73461288          C\n25         NA          D\n16 8.36873466          E\n10 9.41348691          F\n7          NA          G\n18 3.03966738          H\n14         NA          I\n8  2.87736186          J\n17 2.61218835          K\n12 0.78149664          L\n22         NA          M\n23         NA          N\n20         NA          O\n24 7.16238291          P\n13 9.89804595          Q\n4  0.05855219          R\n1  2.89877034          S\n6  3.19831342          T\n15 2.69986254          U\n5  7.77843387          V\n3  1.35145397          W\n11 1.21423347          X\n19 1.47811105          Y\n26         NA          Z\n\n# Identify which rows have missing values in my_unis (single line)\nwhich(is.na(my_df$my_unis))\n\n[1]  1  4  7  9 13 14 15 26\n\n# Re-order the entire data frame alphabetically by my_letters\nmy_df &lt;- my_df[order(my_df$my_letters), ]\nmy_df\n\n      my_unis my_letters\n2          NA          A\n9  1.13757144          B\n21 7.73461288          C\n25         NA          D\n16 8.36873466          E\n10 9.41348691          F\n7          NA          G\n18 3.03966738          H\n14         NA          I\n8  2.87736186          J\n17 2.61218835          K\n12 0.78149664          L\n22         NA          M\n23         NA          N\n20         NA          O\n24 7.16238291          P\n13 9.89804595          Q\n4  0.05855219          R\n1  2.89877034          S\n6  3.19831342          T\n15 2.69986254          U\n5  7.77843387          V\n3  1.35145397          W\n11 1.21423347          X\n19 1.47811105          Y\n26         NA          Z\n\n# Calculate the column mean for my_unis\nmean(my_df$my_unis, na.rm = TRUE)\n\n[1] 4.094627"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CompBio_Webpage_Final",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nHomework 3Link\nHomework 4Link"
  },
  {
    "objectID": "Homework 3.html",
    "href": "Homework 3.html",
    "title": "Homework 3 QMD",
    "section": "",
    "text": "QUESTION 1\n\n# Define variables \nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\nz &lt;- x^a^b\nprint (z)\n\n[1] 3.61714\n\n# This computes a^b first, then raises x to that power\nz &lt;- (x^a)^b\nprint (z)\n\n[1] 1.997611\n\nz &lt;- 3*x^3 + 2*x^2 + 1\nz\n\n[1] 7.413\n\n# This evaluates a cubic polynomial at x = 1.1\n\nQUESTION 2\n\n# Create a vector that increases from 1 to 8, then decreases back to 1. Both sequences were put in the same line for sake of convienence. \nv1 &lt;- c(seq(1, 8), seq(7, 1))\n\n# Create a vector where each number i is repeated i times (1 once, 2 twice, etc.)\nv2 &lt;- rep(1:5, times = 1:5)\n# rep() repeats values\n\n# Create a decreasing version of the previous vector, this involves just switching the rep shorthand\nv3 &lt;- rep(5:1, times = 1:5)\n\nQUESTION 3\n\n# Generate two random numbers between 0 and 1 to represent x and y coordinates\ncoords &lt;- runif(2)\n# note: these can be interpreted as (x,y) coordnites \n\n# r is the distance from the origin to the point, this makes it a polar function if it has a noted direction and angel\n\n# Calculate the radius from the origin (0,0), this way you can have the distance from the origin as well as the angle of direction. \n# This uses the Pythagorean theorem: r = sqrt(x^2 + y^2)\nr &lt;- sqrt(coords[1]^2 + coords[2]^2)\n\n# Calculate the angular coordinate (theta) using atan \ntheta &lt;- atan(coords[2] / coords[1])\n# Combine r and theta into vector representing polar coordinates with both angle and radius \npolar &lt;- c(r = r, theta = theta)\npolar\n\n        r     theta \n0.3140167 0.3332757 \n\n\nQUESTION 4\n\n# Creating a vector line of Noahs Ark  \n# Initial queue (sheep is at the front)\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\n# The serpent arrives and gets in line (at the end)\nqueue &lt;- c(queue, \"serpent\")\n# The sheep (which is the first animal) enters the ark (leaves from the front)\nqueue &lt;- queue[-1]\n# The donkey arrives and gets to the front of the line in front of the rest of the queue? \nqueue &lt;- c(\"donkey\", queue)\n# The serpent leaves, use exclimation point \nqueue &lt;- queue[queue != \"serpent\"]\n# The owl also leaves\nqueue &lt;- queue[queue != \"owl\"]\n# The aphid arrives and the ant say to cut him in line, use the double == sign to say equal\nant_pos &lt;- which(queue == \"ant\")\nqueue &lt;- append(queue, \"aphid\", after = ant_pos - 1)\n\n# input final queue\nqueue\n\n[1] \"donkey\" \"fox\"    \"aphid\"  \"ant\"   \n\n# figure out the position of the ant, aka, what is the position equal to  \nwhich(queue == \"aphid\")\n\n[1] 3\n\n# he is in position three\n\nQUESTION 5\n\n#integers from 1 to 100 that are not divisable by 2, 3 or 7 \nnums &lt;- 1:100\nsubset(1:100, (1:100) %% 2 != 0 & (1:100) %% 3 != 0 & (1:100) %% 7 != 0)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97\n\n# creating subset, adding all of the conditions"
  }
]